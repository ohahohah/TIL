## 변화는 어떨게 만들어 갈 것인가?
- 변화에 실패한 경험이 - 패배의식을 만들 수 있다.
- `작은 성공` 으로 성취감과 안정감을 가지고 더 큰 변화로
- 회고 - 우선순위가 높으면서, 작은 변화로도 영향력이 클만한 Practice 선택 -> 한가지에 집중 -> 작은 성공 -> 반복
  - 팀이 같이 작은 성공을 맛보는 것!
  - 점심먹고 십분동안 산책하면서 이야기해보자(회고).
  - 내가 성공했었던 경험으로 나중에 팀에도 적용해보자.

### 현장에 TDD, 리팩토링 적용하기
- 토이프로젝트로 해보기 -> 현업코드에 적용해보기 -> 내 코드에 관심가지는 사람이 생기면 페어프로그래밍으로 동료와 같이해보기 -> 점차 전파해나가기
  - 지금 하고 있는 코드스쿼드 미션 사용해서 한번 페어프로그래밍 시도해봐라
  - 초심자들끼리 해도 서로 피드백하면서 나아가라 (완전 시니어가 없어도 괜찮다)

## 실패해도 괜찮아
- 변화를 만들다 실패해도 괜찮아. 시도하면서 자심감과 용기 근육을 키우자

## 업계에서의 리팩토링 역할
- 처음부터 새로 만드는 것보다 점차 시스템을 개선해나가는 경우가 많음
- 기존 코드를 개선해낼 수 있는 리팩토링 역량이 중요해진다! 

---------
## 로또 리뷰
- 먼저, 로직의 입력-출력이 뭔지 생각해보자. 객체 설계 고민은 어려우니까 이거 먼저.
- 테스트 포인트를 줄이기. 머리써야할 일이 많아지면 테스트케이스가 너무 큰 건 아닌지 생각해보자.
```
match(Lotto ){

}

int matchCount(){
if(winnigLott.contains(lotto)){
    return 1;
}
return 0;
""
```
- 일급콜렉션
  - 유효성 체크에 유효하네? 일급콜렉션이 아니라면, public 으로 변경해서 각각 메소드마다 파라미터의 유효성체크를 해야할까? 
  - 파라미터 중에 객체로 바꿀 수 있는게 있을까? 고민해보자

- Lottto 객체
  - 중복검사대신 (중복이 허용되지 않는)Set을 사용해보자
  - **생성자가 두 개이상아라면, 팩토리 메소드를 사용해서 의도를 드러낼 수 있다.**
    - of { return new Lotto();} 

- 리팩토링 연습
  - 중요! 기존 코드를 망가뜨리지 않으면서 리팩토링하는 연습하기!
  - Step by step
    - 잘 동작하는 코드를 복제본을 떠서 다른 이름을 부여함. - 데이터베이스 리팩토링도 이렇게 백업만들면서!
      - 안전한 배포가 가능해진다 - 무중단배포!(진정한 무중단배포는 클라우드 서비스 환경 구성만이 끝이 아니다!!!)
      - 이 코드를 쓰는 곳이 한군데도 없으니까 자유롭게 수정하기 시작함.
      - 테스트코드도 복제본을 따로 떠서 만들어도 됨 
      - 리팩토링을 하고 이제는 안쓰게된 예전 동작 코드를 지우자
      - 신난다!
- 객체가 데이터를 처리하면, 파라미터가 줄어드네

- 객체와 연관된 로직부분을 객체 안으로 끌어들인다
  - 외부에서 get으로 사용할때는 중복로직이 발생해서 나중에 관리가 어려워짐
  - [ ] 객체지향개념을 좀 더 알 수 있는 입문 콘텐츠로 학습해보자

- 잘게 쪼개다보면 인스턴스가 많아짐 -> 인스턴스 캐싱해서 재사용하자.
- LottoNums 가 valueObject! 값을 변경할 수가 없다고! DTO가 아니라고!
- Money로 객체를 만들어도 또 된당
- TDD로 하다보면, 객체의 구조 도출이 됨.
- 외부에서 객체로 메시지를 전달하는 버릇이 되면 나중에 Spring의 DI의 필요성을 깨닫게 되는게 많다.
- 테스트 가능한 코드를 만들다보면 객체지향적으로 사고하기 쉬워진다

- live-coding  branch에 라이브코딩 기준 자료가 있음
- 상수값을 enum으로 관리해보자
  - [ ] enum 배우기 

---------
## 함수형 프로그래밍
- sideeffect 를 줄인다.
- 객체지향적으로 설계를 하고 메소드를 함수형 프로그래밍으로 설계해보면 어떨까?
- input과 output을 같게
- hadoop의 mapReduce 도 함수형 프로그래밍의 map 과 reduce 에서 힌트를 얻어 나왔다고 하네요.

### 람다
- 콜백클래스가 람다로!
- 인터페이스에 메소드가 하나여야 가능하다. 한 개 이상이면 어느 메소드를 찾아들어갈지 모르잖앙ㅠ
- 람다 쓰기 좋은 코드 - 앞부분과 뒷부분을 
- 람다함수 처음 써볼때 좋은 접근 방법
  - 1. 중복부분을 interface 로 추출
  - 2. interace를 익명클래스로 구현
  - 3. 익명클래스를 람다로 바꿔보기

### 기존 if 문 사용을 filter로 바꿔보자

### Optional
- null pointer를 막자
- 어느 부분에 Optional을 써야할까? 그러지 말아야할 경우는?

### Java 의 하위호환성
- 다른 언어와 달리 Java는 왜 `stream()`, `collect(Collectors.toList())` 해야할까?
  - Java는 하위호환성을 보장하면서 발전하기 때문에 이런 부분이 생겨남.
```
public static List<Integer> doubleNumbers(List<Integer> numbers) {
        return numbers.stream().map(x -> 2 * x).collect(Collectors.toList());
    }
```

### 기존 작성 코드에 함수형프로그래밍 적용해보자
------
## itelliJ shortcut
- `iter` : for문 생성 : `for(String s : inputs){}`

## 느낀 거
- 고민하던 '리팩토링의 기준이 무엇인가?' -> 보다 객체지향적으로 변경해나가는 것(객체지향체조 참고)으로 잡아보자.
